// 공사비용
// 주어진 공사비로 가장 긴 연속구간을 보수 공사한다고 할 때 
// 매개변수 cost에 각 구간의 공사비용 정보가 배열로 주어지고,
// 주어진 공사예산 m을 가지고 공사가능한 가장 긴 연속 구간의 길이를 구하는 프로그램

function solution(cost, m){
  // left 인덱스와 right 인덱스, 부분합
  let lt = 0, sum = 0, answer = 0, distance = 0
  // 먼저 오른쪽 포인터를 하나 움직이고 합을 구한다.
  for(let rt = 0; rt < cost.length; rt += 1) {
    sum += cost[rt];
    // 위의 합이 주어진 부분합보다 작거나 같으면 아래 while문은 수행되지 않고 내려간다. 
    // 이중 반복문 같아서 O(N^2)같아보이지만, 안의 while문만 lt이 증가하면서 바깥 반복문과 상관없이 
    // 자기만 돌기 때문에 O(N)이다. 
    while(sum > m) {
      // 오른쪽을 움직이면 더한 합이 주어진 부분합보다 커지면(같지 않고)
      // 왼쪽 포인터를 오른쪽으로 움직이면서(합을 줄이면서) 합이 주어진 부분합에 가까워지도록 해본다.
      sum -= cost[lt]
      lt += 1
    // 다시 while문으로 올라가서 여전히 주어진 부분합(m)이 크면 계속 왼쪽 포인터를 움직일 것이다.
    // 그러다 합이 주어진 부분합보다 작거나 같아지면 while문을 빠져나오게 된다.
    }
    // cost가 주어진 예산 m가 같거나 막 작아질때 그간의 공사구간을 담는다.
    distance = rt-lt+1
    // 그 전에 담아두었던 값과 비교해 큰 값을 담아둔다.
    answer = Math.max(answer, distance)
  }  
  return answer 
}

console.log(solution([0, 150, 100, 0, 150, 0, 70, 140], 350));
console.log(solution([100, 200, 300, 400, 500, 100], 300));
console.log(solution([100, 50, 120, 50, 150, 0, 50, 60], 400));
