// 봉우리
// 매개변수 board에 각각의 높이가 쓰여있다. 자신의 상하좌우보다 높은 봉우리 지역은 몇 개 있는지 알아내는 프로그램을 작성

function solution(board) {
  let answer = 0
  let n = board.length
  // 기준 요소의 상하자우 x 좌표의 상대적 위치를 나타내는 배열 [좌, 상, 우, 하]
  let dx = [-1, 0, 1, 0]
  let dy = [0, -1, 0, 1]
  // 이 때 인덱스를 의미하는 i, j는 격자 가장자리 제외하고 시작
  for(let i = 0; i < n; i += 1) {
    for(let j = 0; j < n; j += 1) {
      // 우선 해당 요소가 봉우리(참)라고 초기화 시킴, 트루시한 값 1을 넣어도 가능
      let peak =  true
      for(let k = 0; k < 4; k += 1) {
        // 각 방향으로 돌아가면서 기준 요소 인덱스(i)에 -1, 0, 1(k)을 더해주면서
        // 네 방향 요소의 행과 열의 인덱스를 구한다.
        // dk[0] = -1, dk[1] = 0, ...
        let newX = i + dx[k]
        let newY = j + dy[k]
        // 가장자리 제외한 board의 범위(0<= 인덱스 < n)에서, 기준 값이 새 좌표의 값보다 작으면 봉우리가 아님 
        if(newX >= 0 && newX < n && newY >= 0 && newY < n && board[i][j] <= board[newX][newY]) {
          peak = false
          break
        }
      }
      // peak이 true이면 전체 카운트를 올려줌 
      if(peak) answer += 1
    }
  }
  return answer
}


console.log(solution([[5, 3, 7, 2, 3], [3, 7, 1, 6, 1], [7, 2, 5, 3, 4], [4, 3, 6, 4, 1], [8, 7, 3, 5, 2]]))
console.log(solution([[11, 15, 17, 23, 13, 5, 12], [25, 18, 11, 16, 21, 7, 22], [37, 13, 17, 22, 14, 11, 33], [35, 27, 38, 34, 31, 22, 12], [38, 22, 33, 21, 25, 33, 11], [11, 33, 12, 13, 26, 35, 12], [17, 22, 23, 11, 15, 13, 21]]))
